let yearCountSlider = $('yearCountSlider');
let documentCountSlider = $('documentCountSlider');

const MAX_YEAR_COUNT = 1780;
const yearCountPipsStep = 500;
let yearCountPips = [1]
for (let v = yearCountPipsStep; v <= MAX_YEAR_COUNT ; v += yearCountPipsStep) {
    yearCountPips.push(v);
}

// Remove the dummy HTML slider
yearCountSlider.innerHTML = ""
yearCountSlider.classList.add("slider-styled");
noUiSlider.create(yearCountSlider, {
    start: [1, MAX_YEAR_COUNT],
    connect: true,
    step: 1,
    tooltips: true,
    format: {
        to: (numberValue) => Math.round(numberValue),
        from: (stringValue) => Number(stringValue.replace(',-', ''))
    },
    pips: {
        mode: 'values',
        values: yearCountPips,
        density: 4
    },
    range: {
        'min': 1,
        'max': MAX_YEAR_COUNT
    },
    handleAttributes: [
        {"aria-label": "Earliest date"},
        {"aria-label": "Latest date"}
    ]
});

// Ignore all parameters passed to the callback
yearCountSlider.noUiSlider.on("change",
    noUiSliderCallbackArgs => updatePostGrid(yearCountSlider));

/* Layers can go up to 32 in QMK but it's very unlikely to encounter more than
 * 16 layers in a database so in order to make the slider more comfortable to use,
 * we limit the max to 16. However, we can and should change that if we do find
 * a database with more 16 layers.
 *
 * EDIT: 32-layer database found! See posts/database/rafaelromao.md @ PR#66
 */
const MAX_DOCUMENT_COUNT = 65;
const documentCountPipsStep = 15;
let documentCountPips = [1]
for (let v = documentCountPipsStep; v <= MAX_DOCUMENT_COUNT ; v += documentCountPipsStep) {
    documentCountPips.push(v);
}

documentCountSlider.innerHTML = ""
documentCountSlider.classList.add("slider-styled");
noUiSlider.create(documentCountSlider, {
    start: [1, MAX_DOCUMENT_COUNT],
    connect: true,
    step: 1,
    tooltips: true,
    format: {
        to: (numberValue) => Math.round(numberValue),
        from: (stringValue) => Number(stringValue.replace(',-', ''))
    },
    pips: {
        mode: 'values',
        values: documentCountPips,
        density: 7,
    },
    range: {
        'min': 1,
        'max': MAX_DOCUMENT_COUNT,
    },
    handleAttributes: [
        {"aria-label": "Minimum document count"},
        {"aria-label": "Maximum document count"}
    ]
});

// Ignore all parameters passed to the callback
documentCountSlider.noUiSlider.on("change",
    noUiSliderCallbackArgs => updatePostGrid(documentCountSlider));


// Source: https://refreshless.com/nouislider/examples/#section-merging-tooltips
/**
 * @param slider HtmlElement with an initialized slider
 * @param threshold Minimum proximity (in percentages) to merge tooltips
 * @param separator String joining tooltips
 */
function mergeTooltips(slider, threshold, separator) {

    var textIsRtl = getComputedStyle(slider).direction === 'rtl';
    var isRtl = slider.noUiSlider.options.direction === 'rtl';
    var isVertical = slider.noUiSlider.options.orientation === 'vertical';
    var tooltips = slider.noUiSlider.getTooltips();
    var origins = slider.noUiSlider.getOrigins();

    // Move tooltips into the origin element. The default stylesheet handles this.
    tooltips.forEach(function (tooltip, index) {
        if (tooltip) {
            origins[index].appendChild(tooltip);
        }
    });

    slider.noUiSlider.on('update', function (values, handle, unencoded, tap, positions) {

        var pools = [[]];
        var poolPositions = [[]];
        var poolValues = [[]];
        var atPool = 0;

        // Assign the first tooltip to the first pool, if the tooltip is configured
        if (tooltips[0]) {
            pools[0][0] = 0;
            poolPositions[0][0] = positions[0];
            poolValues[0][0] = values[0];
        }

        for (var i = 1; i < positions.length; i++) {
            if (!tooltips[i] || (positions[i] - positions[i - 1]) > threshold) {
                atPool++;
                pools[atPool] = [];
                poolValues[atPool] = [];
                poolPositions[atPool] = [];
            }

            if (tooltips[i]) {
                pools[atPool].push(i);
                poolValues[atPool].push(values[i]);
                poolPositions[atPool].push(positions[i]);
            }
        }

        pools.forEach(function (pool, poolIndex) {
            var handlesInPool = pool.length;

            for (var j = 0; j < handlesInPool; j++) {
                var handleNumber = pool[j];

                if (j === handlesInPool - 1) {
                    var offset = 0;

                    poolPositions[poolIndex].forEach(function (value) {
                        offset += 1000 - value;
                    });

                    var direction = isVertical ? 'bottom' : 'right';
                    var last = isRtl ? 0 : handlesInPool - 1;
                    var lastOffset = 1000 - poolPositions[poolIndex][last];
                    offset = (textIsRtl && !isVertical ? 100 : 0) + (offset / handlesInPool) - lastOffset;

                    // Filter out duplicate tool tip values
                    var tooltipValues = poolValues[poolIndex].filter((v, i, a) => a.indexOf(v) === i);

                    // Center this tooltip over the affected handles
                    tooltips[handleNumber].innerHTML = tooltipValues.join(separator);
                    tooltips[handleNumber].style.display = 'block';
                    tooltips[handleNumber].style[direction] = offset + '%';
                } else {
                    // Hide this tooltip
                    tooltips[handleNumber].style.display = 'none';
                }
            }
        });
    });
}

// Not an ASCII hyphen, the separator is an en-dash
//<–> 8211, Hex 2013, Oct 20023, Digr -N
mergeTooltips(yearCountSlider, 15, '–');
mergeTooltips(documentCountSlider, 15, '–');
